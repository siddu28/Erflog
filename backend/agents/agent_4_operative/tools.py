import os
import json
import tempfile
from dotenv import load_dotenv
from langchain_google_genai import ChatGoogleGenerativeAI
from langchain_core.prompts import ChatPromptTemplate
from langchain_core.output_parsers import JsonOutputParser
import fitz  # PyMuPDF
from supabase import create_client

load_dotenv()


# =============================================================================
# DATABASE HELPERS
# =============================================================================

def fetch_user_profile_by_uuid(user_id: str) -> dict:
    """Fetches full user profile from Supabase by user_id (UUID)."""
    from core.db import db_manager
    
    supabase = db_manager.get_client()
    # Schema check: profiles table has resume_json
    response = supabase.table("profiles").select("*").eq("user_id", user_id).execute()
    
    if not response.data:
        raise ValueError(f"Profile with user_id '{user_id}' not found")
    
    return response.data[0]


def save_application_to_db(
    user_id: str,
    job_id: int,
    tailored_resume_url: str,
    custom_responses: dict = None
) -> dict:
    """
    Saves the generated application details to the 'applications' table.
    """
    from core.db import db_manager
    supabase = db_manager.get_client()
    
    data = {
        "user_id": user_id,
        "job_id": job_id,
        "tailored_resume_url": tailored_resume_url,
        "status": "generated",
        "is_auto_generated": True,
        "updated_at": "now()"
    }
    
    if custom_responses:
        data["custom_responses"] = custom_responses

    try:
        # Check if application exists for this user and job
        existing = supabase.table("applications").select("id").eq("user_id", user_id).eq("job_id", job_id).execute()
        
        if existing.data:
            # Update existing application
            app_id = existing.data[0]['id']
            print(f"üíæ [Agent 4] Updating existing application ID: {app_id}")
            response = supabase.table("applications").update(data).eq("id", app_id).execute()
        else:
            # Insert new application
            print(f"üíæ [Agent 4] Creating new application record")
            # Add created_at for new records if not auto-generated by DB
            data["created_at"] = "now()"
            response = supabase.table("applications").insert(data).execute()
            
        return response.data[0] if response.data else {}
    except Exception as e:
        print(f"‚ö†Ô∏è [Agent 4] Failed to save application to DB: {e}")
        return {}


# =============================================================================
# STEP 1: Download Original PDF from Supabase Storage
# =============================================================================

def download_original_pdf(user_id: str) -> str:
    """
    Downloads the original PDF from Supabase Storage.
    """
    supabase_url = os.getenv("SUPABASE_URL")
    service_key = os.getenv("SUPABASE_SERVICE_ROLE_KEY") or os.getenv("SUPABASE_KEY")
    
    if not supabase_url or not service_key:
        raise ValueError("SUPABASE_URL and key must be set in .env")
    
    supabase = create_client(supabase_url.rstrip('/'), service_key)
    
    bucket_name = "Resume"
    file_name = f"{user_id}.pdf"
    
    print(f"üì• [Agent 4] Downloading original PDF: {file_name}")
    
    try:
        # Download file from Supabase storage
        response = supabase.storage.from_(bucket_name).download(file_name)
        
        # Save to temp file
        temp_dir = tempfile.gettempdir()
        temp_path = os.path.join(temp_dir, f"original_{user_id}.pdf")
        
        with open(temp_path, "wb") as f:
            f.write(response)
        
        print(f"   ‚úÖ Downloaded to: {temp_path}")
        return temp_path
        
    except Exception as e:
        print(f"   ‚ùå Download failed: {e}")
        raise Exception(f"Failed to download original PDF: {str(e)}")


# =============================================================================
# STEP 2: Extract Text Sections from PDF
# =============================================================================

def extract_text_sections(pdf_path: str) -> dict:
    """
    Extracts text sections from PDF for editing.
    """
    print(f"üìÑ [Agent 4] Extracting text sections from PDF...")
    
    doc = fitz.open(pdf_path)
    full_text = ""
    page_texts = []
    
    for page_num, page in enumerate(doc):
        page_text = page.get_text()
        full_text += page_text + "\n"
        page_texts.append({
            "page": page_num,
            "text": page_text
        })
    
    doc.close()
    
    print(f"   ‚úÖ Extracted {len(full_text)} characters from {len(page_texts)} pages")
    
    return {
        "full_text": full_text,
        "page_texts": page_texts
    }


# =============================================================================
# STEP 3: Gemini Fine-Tunes Sections for Target Job
# =============================================================================

def finetune_resume_for_job(original_text: str, job_description: str) -> dict:
    """
    Uses Gemini to fine-tune resume text for a specific job.
    """
    print(f"üß† [Agent 4] Fine-tuning resume with Gemini...")
    
    llm = ChatGoogleGenerativeAI(
        model="gemini-2.0-flash",
        google_api_key=os.getenv("GEMINI_API_KEY"),
        temperature=0.2
    )
    
    json_parser = JsonOutputParser()
    
    prompt = ChatPromptTemplate.from_messages([
        ("system", """You are a resume fine-tuner. Your job is to identify SPECIFIC phrases in the resume that can be slightly modified to better match the job description.

CRITICAL RULES:
1. Find exact phrases from the resume that can be improved
2. Only modify 3-5 phrases maximum
3. Changes must be MINIMAL - add 1-2 keywords, don't rewrite
4. Replacements must be similar length to originals
5. DO NOT change names, emails, dates, company names, job titles
6. Only modify description/summary/bullet point text

OUTPUT FORMAT - Return ONLY valid JSON:
{{
    "replacements": [
        {{
            "original": "exact phrase from resume to find",
            "replacement": "slightly modified phrase with keyword added",
            "reason": "why this change helps"
        }}
    ],
    "keywords_added": ["keyword1", "keyword2"]
}}

IMPORTANT: The "original" field must contain EXACT text that appears in the resume."""),
        ("human", """RESUME TEXT:
{resume_text}

JOB DESCRIPTION:
{job_description}

Find 3-5 phrases to slightly modify. Return JSON.""")
    ])
    
    chain = prompt | llm | json_parser
    
    try:
        result = chain.invoke({
            "resume_text": original_text[:4000],  # Limit to avoid token issues
            "job_description": job_description[:2000]
        })
        
        replacements = result.get("replacements", [])
        keywords = result.get("keywords_added", [])
        
        print(f"   ‚úÖ Found {len(replacements)} phrases to modify")
        
        return result
        
    except Exception as e:
        print(f"   ‚ùå Gemini error: {e}")
        return {"replacements": [], "keywords_added": []}


# =============================================================================
# STEP 4: PyMuPDF Find & Replace in Original PDF
# =============================================================================

def edit_pdf_with_replacements(pdf_path: str, replacements: list) -> str:
    """
    Edits text in the original PDF using PyMuPDF.
    """
    print(f"‚úèÔ∏è [Agent 4] Editing PDF with {len(replacements)} replacements...")
    
    if not replacements:
        print("   ‚ö†Ô∏è No replacements to make, returning original")
        return pdf_path
    
    doc = fitz.open(pdf_path)
    changes_made = 0
    
    for page_num, page in enumerate(doc):
        for rep in replacements:
            original = rep.get("original", "")
            replacement = rep.get("replacement", "")
            
            if not original or not replacement:
                continue
            
            # Search for the original text
            text_instances = page.search_for(original)
            
            if text_instances:
                for inst in text_instances:
                    # Add redaction annotation to remove old text
                    page.add_redact_annot(inst, fill=(1, 1, 1))  # White fill
                
                # Apply all redactions on this page
                page.apply_redactions()
                
                # Insert new text at the first instance location
                for inst in text_instances:
                    # Calculate font size based on rectangle height
                    rect_height = inst.height
                    font_size = min(max(rect_height * 0.8, 8), 12)
                    
                    # Insert new text
                    page.insert_text(
                        (inst.x0, inst.y0 + rect_height * 0.8),
                        replacement,
                        fontsize=font_size,
                        color=(0, 0, 0)
                    )
                    changes_made += 1
                    break  # Only replace first instance
    
    # Save to new file
    output_dir = tempfile.gettempdir()
    user_id = os.path.basename(pdf_path).replace("original_", "").replace(".pdf", "")
    output_path = os.path.join(output_dir, f"mutated_{user_id}.pdf")
    
    doc.save(output_path)
    doc.close()
    
    print(f"   ‚úÖ Made {changes_made} changes, saved to: {output_path}")
    return output_path


# =============================================================================
# STEP 5: Upload Mutated PDF to Supabase Storage
# =============================================================================

def upload_mutated_pdf(pdf_path: str, user_id: str) -> str:
    """
    Uploads the mutated PDF to Supabase Storage.
    """
    supabase_url = os.getenv("SUPABASE_URL")
    service_key = os.getenv("SUPABASE_SERVICE_ROLE_KEY") or os.getenv("SUPABASE_KEY")
    
    supabase = create_client(supabase_url.rstrip('/'), service_key)
    
    bucket_name = "Resume"
    file_name = f"{user_id}_mutated.pdf"
    
    print(f"üì§ [Agent 4] Uploading mutated PDF: {file_name}")
    
    try:
        with open(pdf_path, "rb") as f:
            file_data = f.read()
        
        # Remove existing file if any
        try:
            supabase.storage.from_(bucket_name).remove([file_name])
        except:
            pass
        
        # Upload
        supabase.storage.from_(bucket_name).upload(
            path=file_name,
            file=file_data,
            file_options={"content-type": "application/pdf"}
        )
        
        # Generate signed URL (1 year)
        signed_url_response = supabase.storage.from_(bucket_name).create_signed_url(
            path=file_name,
            expires_in=31536000
        )
        
        if isinstance(signed_url_response, dict):
            signed_url = signed_url_response.get("signedURL") or signed_url_response.get("signedUrl")
        else:
            signed_url = str(signed_url_response)
        
        print(f"   ‚úÖ Uploaded successfully!")
        print(f"   üìé URL: {signed_url[:80]}...")
        
        return signed_url
        
    except Exception as e:
        print(f"   ‚ùå Upload failed: {e}")
        raise Exception(f"Failed to upload mutated PDF: {str(e)}")


# =============================================================================
# MAIN FUNCTION: Complete PDF Mutation Flow
# =============================================================================

def mutate_resume_for_job(user_id: str, job_description: str) -> dict:
    """
    Complete flow to mutate a resume for a specific job.
    
    Args:
        user_id: The UUID that matches the PDF filename in Supabase storage ({user_id}.pdf)
        job_description: Target job description
    """
    print(f"\n{'='*60}")
    print(f"üöÄ [Agent 4] Starting Resume Mutation for user: {user_id}")
    print(f"   Will download: {user_id}.pdf from Supabase Storage")
    print(f"{'='*60}\n")
    
    try:
        # Step 1: Download original PDF
        original_pdf_path = download_original_pdf(user_id)
        
        # Step 2: Extract text sections
        text_data = extract_text_sections(original_pdf_path)
        
        # Step 3: Gemini fine-tunes for job
        finetune_result = finetune_resume_for_job(
            text_data["full_text"],
            job_description
        )
        
        replacements = finetune_result.get("replacements", [])
        keywords_added = finetune_result.get("keywords_added", [])
        
        # Step 4: Edit PDF with replacements
        mutated_pdf_path = edit_pdf_with_replacements(original_pdf_path, replacements)
        
        # Step 5: Upload mutated PDF
        pdf_url = upload_mutated_pdf(mutated_pdf_path, user_id)
        
        print(f"\n{'='*60}")
        print(f"‚úÖ [Agent 4] Resume Mutation Complete!")
        print(f"{'='*60}\n")
        
        return {
            "status": "success",
            "pdf_url": pdf_url,
            "pdf_path": mutated_pdf_path,
            "changes_made": len(replacements),
            "keywords_added": keywords_added,
            "replacements": replacements,
            "message": f"Resume optimized with {len(replacements)} changes for the target job."
        }
        
    except Exception as e:
        print(f"\n‚ùå [Agent 4] Error: {e}")
        import traceback
        traceback.print_exc()
        return {
            "status": "error",
            "error": str(e),
            "message": f"Failed to mutate resume: {str(e)}"
        }


# =============================================================================
# REWRITE RESUME CONTENT FOR JOB DESCRIPTION
# =============================================================================

def rewrite_resume_content(user_profile: dict, job_description: str) -> dict:
    """
    Rewrite resume content to better match the job description.
    
    Args:
        user_profile: User's profile/resume data.
        job_description: Target job description.
    
    Returns:
        Dictionary with rewritten resume sections.
    """
    # TODO: Implement actual resume rewriting logic with LLM
    # For now, return the profile as-is
    return {
        "summary": user_profile.get("summary", ""),
        "experience": user_profile.get("experience", []),
        "skills": user_profile.get("skills", []),
        "education": user_profile.get("education", []),
        "rewritten": True
    }


# =============================================================================
# ADDITIONAL HELPER FUNCTIONS FOR SERVICE
# =============================================================================

def fetch_user_profile(user_id: str) -> dict:
    """Alias for fetch_user_profile_by_uuid for backward compatibility."""
    return fetch_user_profile_by_uuid(user_id)


def build_resume_from_profile(profile: dict) -> dict:
    """
    Builds a structured resume dict from a Supabase profile record.
    
    Args:
        profile: Raw profile data from Supabase profiles table.
    
    Returns:
        Structured resume dictionary.
    """
    # Extract resume_json if available, otherwise build from profile fields
    resume_json = profile.get("resume_json", {}) or {}
    
    return {
        "name": profile.get("name") or resume_json.get("name", ""),
        "email": profile.get("email") or resume_json.get("email", ""),
        "phone": resume_json.get("phone", ""),
        "location": resume_json.get("location", ""),
        "linkedin": profile.get("linkedin_url") or resume_json.get("linkedin", ""),
        "github": profile.get("github_url") or resume_json.get("github", ""),
        "summary": profile.get("experience_summary") or resume_json.get("summary", ""),
        "experience_summary": profile.get("experience_summary", ""),
        "skills": profile.get("skills", []) or resume_json.get("skills", []),
        "education": profile.get("education") or resume_json.get("education", ""),
        "experience": resume_json.get("experience", []),
        "projects": resume_json.get("projects", []),
        "certifications": resume_json.get("certifications", []),
        "resume_url": profile.get("resume_url", ""),
        "resume_text": profile.get("resume_text", ""),
        "resume": resume_json  # Keep full resume_json for backward compatibility
    }


def find_recruiter_email(company_domain: str) -> dict:
    """
    Attempts to find recruiter email for a company.
    
    Args:
        company_domain: Company domain (e.g., 'google.com')
    
    Returns:
        Dict with email and confidence score.
    """
    if not company_domain:
        return {"email": None, "confidence": 0, "source": "none"}
    
    # Common recruiter email patterns
    patterns = [
        f"recruiting@{company_domain}",
        f"careers@{company_domain}",
        f"jobs@{company_domain}",
        f"hr@{company_domain}",
        f"talent@{company_domain}"
    ]
    
    # For now, return the most common pattern
    # In production, you'd verify these with an email validation API
    return {
        "email": patterns[0],
        "confidence": 0.6,
        "source": "pattern_match",
        "alternatives": patterns[1:]
    }


def generate_application_responses(
    user_profile: dict,
    job_description: str,
    company_name: str,
    job_title: str,
    additional_context: str = None
) -> dict:
    """
    Generate copy-paste ready responses for common job application questions.
    
    Args:
        user_profile: User's profile/resume data.
        job_description: Target job description.
        company_name: Name of the company.
        job_title: Title of the position.
        additional_context: Any additional context.
    
    Returns:
        Dictionary with all application responses.
    """
    from langchain_google_genai import ChatGoogleGenerativeAI
    from langchain_core.prompts import ChatPromptTemplate
    from langchain_core.output_parsers import JsonOutputParser
    
    llm = ChatGoogleGenerativeAI(
        model="gemini-2.0-flash",
        google_api_key=os.getenv("GEMINI_API_KEY"),
        temperature=0.3
    )
    
    json_parser = JsonOutputParser()
    
    prompt = ChatPromptTemplate.from_messages([
        ("system", """You are a professional career coach helping candidates write compelling job application responses.

Generate personalized, authentic responses based on the candidate's profile. Each response should:
- Be specific to the company and role
- Reference actual experience from their profile
- Sound natural, not robotic
- Be concise but comprehensive (2-4 sentences each)

OUTPUT FORMAT - Return ONLY valid JSON:
{{
    "why_join_company": "Why do you want to join this company?",
    "about_yourself": "Tell us about yourself / Professional summary",
    "relevant_skills": "Relevant skills and technical expertise",
    "work_experience": "Work experience and key achievements",
    "why_good_fit": "Why are you a good fit for this role?",
    "problem_solving": "Problem-solving example or challenge you've overcome",
    "additional_info": "Additional information you'd like to share",
    "availability": "Availability and logistics"
}}"""),
        ("human", """CANDIDATE PROFILE:
Name: {name}
Skills: {skills}
Experience: {experience_summary}
Education: {education}

COMPANY: {company_name}
POSITION: {job_title}
JOB DESCRIPTION: {job_description}

ADDITIONAL CONTEXT: {additional_context}

Generate compelling responses for each application question.""")
    ])
    
    chain = prompt | llm | json_parser
    
    try:
        result = chain.invoke({
            "name": user_profile.get("name", "Candidate"),
            "skills": ", ".join(user_profile.get("skills", [])[:10]),
            "experience_summary": user_profile.get("experience_summary", user_profile.get("summary", ""))[:1000],
            "education": user_profile.get("education", "")[:500],
            "company_name": company_name,
            "job_title": job_title,
            "job_description": job_description[:2000],
            "additional_context": additional_context or "None provided"
        })
        
        return result
        
    except Exception as e:
        print(f"‚ùå [Agent 4] Error generating responses: {e}")
        # Return default responses on error
        return {
            "why_join_company": f"I am excited about the opportunity to join {company_name}.",
            "about_yourself": user_profile.get("experience_summary", "Experienced professional."),
            "relevant_skills": ", ".join(user_profile.get("skills", [])[:5]),
            "work_experience": "Please see my resume for detailed work experience.",
            "why_good_fit": f"My skills align well with the {job_title} role requirements.",
            "problem_solving": "I approach challenges methodically and collaboratively.",
            "additional_info": "I am eager to contribute to your team.",
            "availability": "I am available for immediate start."
        }


def upload_resume_to_storage(pdf_path: str, user_id: str) -> str:
    """
    Uploads PDF to Supabase Storage and returns signed URL.
    This is used by the graph.py render_node.
    """
    supabase_url = os.getenv("SUPABASE_URL")
    service_key = os.getenv("SUPABASE_SERVICE_ROLE_KEY") or os.getenv("SUPABASE_KEY")
    
    supabase = create_client(supabase_url.rstrip('/'), service_key)
    
    bucket_name = "Resume"
    file_name = f"{user_id}_mutated.pdf"
    
    print(f"üì§ [Agent 4] Uploading PDF: {file_name}")
    
    try:
        with open(pdf_path, "rb") as f:
            file_data = f.read()
        
        # Remove existing file if any
        try:
            supabase.storage.from_(bucket_name).remove([file_name])
        except:
            pass
        
        # Upload
        supabase.storage.from_(bucket_name).upload(
            path=file_name,
            file=file_data,
            file_options={"content-type": "application/pdf"}
        )
        
        # Generate signed URL (1 year)
        signed_url_response = supabase.storage.from_(bucket_name).create_signed_url(
            path=file_name,
            expires_in=31536000
        )
        
        if isinstance(signed_url_response, dict):
            signed_url = signed_url_response.get("signedURL") or signed_url_response.get("signedUrl")
        else:
            signed_url = str(signed_url_response)
        
        print(f"   ‚úÖ Uploaded successfully!")
        return signed_url
        
    except Exception as e:
        print(f"   ‚ùå Upload failed: {e}")
        raise Exception(f"Failed to upload PDF: {str(e)}")
